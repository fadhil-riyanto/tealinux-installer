<script>

	import { getRead, getBlueprint } from '/src/routes/installation/global.js';
	import { invoke } from '@tauri-apps/api/core';
	import List from '$lib/components/partitions/List.svelte';
	import Detail from '$lib/components/partitions/Detail.svelte';
	import Preview from '$lib/components/partitions/Preview.svelte';
	import Navigation from '$lib/components/Navigation.svelte';
	import GlowingText from '$lib/components/ui/GlowingText.svelte';
	import Error from '$lib/components/modals/Error.svelte';

	let selectedDisk = $state(0);
	let selectedPartition = $state(0);

	let showEdit = $state(false);
	let newPartition = $state(false);

	let diskSize = $state(0);
	let diskPath = $state('');

	let firmwareType = $state('');

	let originalPartition = $state([]);
	let modifiedPartition = $state([]);
	let tempModifiedPartition = $state([]);
    
	let newPartitionIndex = $state(0);
	let showWarningModal = $state(false);
	let warningMessage = $state("This action will reset all your data. Please backup your data before proceeding.");

	let storage = $state({
		diskPath: null,
		partitionTable: null,
		newPartitionTable: false,
		layoutChanged: false,
		autogenerated: false,
		autogeneratedMode: '',
		installMethod: 'manual',
		partitions: null,
	});

	const setup = async () => {

        let read = await getRead();
        let blueprint = await getBlueprint();

        firmwareType = read.firmware;

        let selectedDiskPath = blueprint.storage.diskPath || null;

        selectedDisk = read.disk.find(disk => disk.diskPath === selectedDiskPath) || null;

		modifiedPartition = [];
		tempModifiedPartition = [];
		originalPartition = [];

		storage.diskPath = selectedDiskPath;
		storage.partitions = selectedDisk.partitions || null;

		let partitions = selectedDisk.partitions;
		diskSize = selectedDisk.size;
		diskPath = selectedDisk.diskPath;

		for (let i of partitions.keys()) {
			let p = {
				number: Number(partitions[i].number),
				diskPath,
				path: partitions[i].partitionPath,
				size: Number(partitions[i].size.slice(0, -1)),
				start: Number(partitions[i].start.slice(0, -1)),
				end: Number(partitions[i].end.slice(0, -1)),
				filesystem: partitions[i].filesystem,
				label: null,
				format: false,
				mountpoint: null,
				label: partitions[i].name,
				flags: partitions[i].flags ? partitions[i].flags : [],
				schemas: selectedDisk.label.toLowerCase() === 'gpt' ? 'gpt' : 'mbr'
			};

			modifiedPartition = [...modifiedPartition, p];
		}

		tempModifiedPartition = JSON.parse(JSON.stringify(modifiedPartition));
		originalPartition = JSON.parse(JSON.stringify(modifiedPartition));
	};

	const revertChanges = () => {
		modifiedPartition = JSON.parse(JSON.stringify(originalPartition));
		tempModifiedPartition = JSON.parse(JSON.stringify(originalPartition));
	};

	const isUnallocated = (partition) => {
		return !partition || !partition.path;
	};

	const showNewPartitionTableWarning = () => {
		showWarningModal = true;
	};

	const newPartitionTable = () => {
		showEdit = false;
		storage.newPartitionTable = true;
		showWarningModal = false;

		let partition = {
			number: 1,
			diskPath,
			path: null,
			size: Number(diskSize.slice(0, -1)) - 2048,
			start: 2048,
			end: Number(diskSize.slice(0, -1)) - 1,
			filesystem: null,
			format: false,
			mountpoint: null,
			label: null,
			flags: []
		};

		modifiedPartition = [partition];
		tempModifiedPartition = [partition];
	};

	const cancelNewPartitionTable = () => {
		showWarningModal = false;
	};

	const removePartition = () => {
		let partitionWithTag = modifiedPartition.filter((p) => (p.path ? p.path.includes('#') : false));
		let numbers = partitionWithTag.map((p) => Number(p.path.replace('#', '')));

		if (modifiedPartition[selectedPartition].path.includes('#')) {
			if (numbers) {
				for (let [i, partition] of modifiedPartition.entries()) {
					if (partition.path && partition.path.includes('#')) {
						let number = Number(partition.path.replace('#', ''));
						if (number > 1) {
							modifiedPartition[i].path = `#${number - 1}`;
						}
					}
				}
			}
		}

		tempModifiedPartition[selectedPartition] = {
			...tempModifiedPartition[selectedPartition],
			path: null,
			filesystem: null,
			format: false,
			mountpoint: null,
			label: null,
			flags: []
		};

		modifiedPartition[selectedPartition] = {
			...modifiedPartition[selectedPartition],
			path: null,
			filesystem: null,
			format: false,
			mountpoint: null,
			label: null,
			flags: []
		};

		showEdit = false;
	};

	const handleSetStorage = () => {
		let partitionWithBoot = modifiedPartition.find((p) => p.mountpoint.includes('boot'));
		let partitionWithRoot = modifiedPartition.find((p) => p.mountpoint.includes('/'));

		if (partitionWithBoot && partitionWithRoot) {
			let bootloaderPath = partitionWithBoot.path;
			let bootloader = {
				firmwareType,
				path: bootloaderPath
			};

			let filteredPartition = modifiedPartition.map((p) => {
				return p.path ? (p.path.includes('#') ? { ...p, path: null } : p) : p;
			});

			storage.partitions = filteredPartition;
			invoke('blueprint_set_bootloader', { bootloader: JSON.stringify(bootloader) });
			invoke('blueprint_set_storage', { storage: JSON.stringify(storage) });
		} else {
			alert('Root or EFI partition does not exist');
		}
	};

	$effect(() => {
		for (let i = 0; i < modifiedPartition.length - 1; i += 1) {
			let current = modifiedPartition[i];
			let next = modifiedPartition[i + 1];

			if (!current.path && !next.path) {
				current.size += next.size;
				current.end = current.start + current.size - 1;

				modifiedPartition.splice(i + 1, 1);
				modifiedPartition = modifiedPartition.map((p) =>
					p.number > i + 1 ? { ...p, number: p.number - 1 } : p
				);

				selectedPartition = i;
			}
		}
	});

</script>

{#await setup() then}
	<div class="flex flex-col p-5 gap-y-2">
		<div class="flex justify-between">
			<div class="flex-1 min-w-[300px]">
				<GlowingText size="[28px]" text="Manual Partitions" />
			</div>
			<div class="flex w-[350px] gap-2.5">
				<button
					onclick={showNewPartitionTableWarning}
					class="flex w-full h-[40px] justify-center items-center gap-[7.963px] rounded-[14px] border-[0.239px] border-[#3C6350] bg-[#101010] hover:shadow-[0_0_7.167px_rgba(38,167,104,0.8)] active:shadow-[0_0_7.167px_rgba(38,167,104,0.8)] transition-all duration-200"
				>
					<img src="/plus.svg" alt="icon" />
					<span class="text-[#4CDA95] font-['Plus_Jakarta_Sans'] text-[13px] font-bold leading-[140%]">
						New Partition Table
					</span>
				</button>
			
				<button
					onclick={revertChanges}
					class="flex w-full h-[40px] justify-center items-center gap-[7.963px] rounded-[14px] border-[0.239px] border-[#3C6350] bg-[#101010] hover:shadow-[0_0_7.167px_rgba(38,167,104,0.8)] active:shadow-[0_0_7.167px_rgba(38,167,104,0.8)] transition-all duration-200"
				>
					<img src="/revert.svg" alt="icon" />
					<span class="text-[#4CDA95] font-['Plus_Jakarta_Sans'] text-[13px] font-bold leading-[140%]">
						Revert Changes
					</span>
				</button>
			</div>
		</div>
		
		<div class="">
			<Preview bind:modifiedPartition bind:diskSize />
		</div>

		
		<div class="flex flex-row flex-auto space-x-2 text-white">
			<List
				bind:selectedDisk
				bind:selectedPartition
				bind:modifiedPartition
				bind:originalPartition
				bind:showEdit
				bind:newPartition
				bind:newPartitionIndex
			/>
			
			{#if tempModifiedPartition[selectedPartition]}
				{#if showEdit}
					<Detail
						bind:showEdit
						bind:tempModifiedPartition
						bind:modifiedPartition
						bind:selectedPartition
						bind:newPartition
						bind:storage
						bind:diskSize
						bind:diskPath
						bind:newPartitionIndex
					/>
				{:else}
                    {#key selectedPartition}
                        <Detail
                            readOnly={true}
                            bind:showEdit
                            bind:tempModifiedPartition
                            bind:modifiedPartition
                            bind:selectedPartition
                            bind:newPartition
                            bind:storage
                            bind:diskSize
                            bind:diskPath
                            bind:newPartitionIndex
                        />
                    {/key}
				{/if}
			{/if}
		</div>
	</div>
{/await}

{#if showWarningModal}
	<Error
		message={warningMessage}
		onConfirm={newPartitionTable}
		onCancel={cancelNewPartitionTable}
	/>
{/if}

<Navigation
	currentStep={4}
	currentTitle="Manual Partitioning"
	prevPath="/installation/partitioning"
	nextPath="/installation/account"
	nextAction={handleSetStorage}
/>
