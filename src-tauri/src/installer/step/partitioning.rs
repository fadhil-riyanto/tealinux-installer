use crate::api::get_blueprint_from_opt;
use crate::installer::{BluePrint, Partition};
use crate::read::get_read;
use crate::storage::btrfs::{create_subvolume, mount_subvolume};
use crate::storage::{
    create_new_partition_table, create_new_partition_table_with_partition, format,
    format_unallocated, mount, umount,
};
use duct::cmd;
use std::fs::{create_dir, create_dir_all};
use std::io::{Error, ErrorKind};
use tea_arch_chroot_lib::resource::{ FirmwareKind, MethodKind };
use tea_partition_api_lib::GetDiskInformation;
use std::path::Path;

use tea_partition_generator::mkpart::Partgen;
use tea_partition_generator::mounting::{Mount, MountPoint};

fn force_umount() {
    // Ignore error if the mountpoint is not mounted
    let _ = cmd!("umount", "--recursive", "/tealinux-mount").run();
}

#[tauri::command]
pub async fn test_partitioning()
{
    let blueprint = get_blueprint_from_opt().await;
    let blueprint: BluePrint = serde_json::from_str(&blueprint).unwrap();

    match partitioning(&blueprint) {
        Ok(_) => println!("Partitioning Successful"),
        Err(e) => println!("Huh, as expected: {:#?}", e)
    }
}

pub fn partitioning(blueprint: &BluePrint) -> Result<(), Error> {
    let mut result = Ok(());

    if let Some(storage) = blueprint.storage.as_ref() {
        match storage.install_method
        {
            MethodKind::SINGLE => {
                if storage.autogenerated
                {
                    if let Some(storage_val) = blueprint.storage.clone() {
                        let storage_data: tea_partition_generator::blueprint::Storage = storage_val.into();

                        let method = storage_data.clone();

                        Partgen::do_dangerous_task_on(storage_data.clone(), method.install_method);
                        let mnt = MountPoint::new(storage_data.clone());
                        mnt.mount_all();
                    }
                }
                else
                {
                    result = partitioning_layout_preserved(blueprint);
                }
            },
            MethodKind::DUAL => {
                if storage.autogenerated
                {
                    if let Some(storage_val) = blueprint.storage.clone() {
                        let storage_data: tea_partition_generator::blueprint::Storage = storage_val.into();

                        let method = storage_data.clone();

                        Partgen::do_dangerous_task_on(storage_data.clone(), method.install_method);
                        let mnt = MountPoint::new(storage_data.clone());
                        mnt.mount_all();
                    }
                }
                else
                {
                    result = partitioning_layout_preserved(blueprint);
                }
            },
            MethodKind::MANUAL => {
                if storage.new_partition_table
                {
                    result = partitioning_new_partition_table(blueprint);
                }
                else
                {
                    result = manual_partitioning(blueprint)
                }
            }
        }
    }

    result
}

fn partitioning_new_partition_table(blueprint: &BluePrint) -> Result<(), Error> {
    force_umount();

    let disk_path = &blueprint.storage.as_ref().unwrap().disk_path;
    let partition_table = &blueprint.storage.as_ref().unwrap().partition_table;
    let partitions = blueprint.storage.as_ref().unwrap().partitions.clone();

    let firmware_type = &blueprint.bootloader.as_ref().unwrap().firmware_type;
    let bootloader_path = &blueprint.bootloader.as_ref().unwrap().path;

    create_new_partition_table(
        disk_path.as_ref().unwrap(),
        partition_table.as_ref().unwrap(),
    )?;

    println!("create new partition table done");

    let formatted_partitions = get_formatted_partitions(disk_path.as_ref().unwrap(), partitions.as_ref().unwrap())?;

    println!("partitioning done");

    actual_partitioning(Some(formatted_partitions))?;

    Ok(())
}

fn get_formatted_partitions(disk_path: &str, partitions: &Vec<Partition>) -> Result<Vec<Partition>, Error>
{
    let mut temp_partitions: Vec<Partition> = Vec::new();

    for partition in partitions
    {
        let mut path: Option<String> = None;

        if partition.format
        {
            path = format_unallocated(
                partitions.as_ref(),
                disk_path,
                partition.start,
                partition.end,
                partition.filesystem.as_ref().unwrap(),
                partition.label.clone(),
            )?;
        }

        temp_partitions.push(Partition {
            path,
            ..partition.to_owned()
        })
    }

    Ok(temp_partitions)
}

fn manual_partitioning(blueprint: &BluePrint) -> Result<(), Error>
{
    let disk_path = &blueprint.storage.as_ref().unwrap().disk_path;
    let partition_table = &blueprint.storage.as_ref().unwrap().partition_table;
    let partitions = blueprint.storage.as_ref().unwrap().partitions.clone();

    let formatted_partitions = get_formatted_partitions(disk_path.as_ref().unwrap(), partitions.as_ref().unwrap())?;

    println!("partitioning done");

    actual_partitioning(Some(formatted_partitions))?;

    Ok(())
}

fn partitioning_layout_changed(blueprint: &BluePrint) -> Result<(), Error> {
    todo!();
}

fn partitioning_layout_preserved(blueprint: &BluePrint) -> Result<(), Error> {
    force_umount();

    let firmware_type = &blueprint.bootloader.as_ref().unwrap().firmware_type;
    let bootloader_path = &blueprint.bootloader.as_ref().unwrap().path;

    let partitions = blueprint
        .storage
        .as_ref()
        .unwrap()
        .partitions
        .as_ref()
        .unwrap();

    actual_partitioning(Some(partitions.to_vec()))?;

    match firmware_type {
        FirmwareKind::UEFI => {
            create_dir_all("/tealinux-mount/boot/efi")?;
            mount(
                &bootloader_path.as_ref().unwrap(),
                "/tealinux-mount/boot/efi",
                None,
            )?;
        }

        FirmwareKind::BIOS => (),
    }

    Ok(())
}

pub fn get_boot_mountpoint(blueprint: &BluePrint) -> Option<String> {
    let disk = &blueprint.storage.as_ref().unwrap().partitions;
    let mut boot_mountpoint = None;

    if let Some(disk) = disk {
        let boot_mountpoint_index = disk.iter().position(|f| {
            f.mountpoint.is_some() && f.mountpoint.as_ref().unwrap().contains("boot")
        });

        if let Some(index) = boot_mountpoint_index {
            boot_mountpoint = Some(disk[index].mountpoint.as_ref().unwrap());
        }
    }

    boot_mountpoint.cloned()
}

pub fn get_boot_path(blueprint: &BluePrint) -> Option<String> {
    let disk = &blueprint.storage.as_ref().unwrap().partitions;
    let mut boot_path = None;

    if let Some(disk) = disk {
        let boot_path_index = disk.iter().position(|f| {
            f.path.is_some()
                && f.mountpoint.is_some()
                && f.mountpoint.as_ref().unwrap().contains("boot")
        });

        if let Some(index) = boot_path_index {
            boot_path = Some(disk[index].path.as_ref().unwrap());
        }
    }

    boot_path.cloned()
}

fn actual_partitioning(partitions: Option<Vec<Partition>>) -> Result<(), Error> {

    if !Path::exists(Path::new("/tealinux-mount")) {
        std::fs::create_dir("/tealinux-mount/")?
    }

    match partitions {
        Some(partitions) => {
            // Find partition that assigned as root, and deal with it first

            let root = partitions
                .iter()
                .find(|p| p.mountpoint.as_ref().is_some_and(|m| m.eq("/")));

            let home = partitions
                .iter()
                .find(|p| p.mountpoint.as_ref().is_some_and(|m| m.eq("/home")));

            println!("Checking if root is available");

            if let Some(root) = root {
                println!("It's available");
                let mut path: Option<String> = root.to_owned().path;

                println!("Checking if the root partition is unallocated");
                if root.format && root.path.is_none() && root.filesystem.is_some() {
                    println!("Unallocated root detected! Formatting unallocated partition");
                    path = format_unallocated(
                        &partitions,
                        root.disk_path.as_ref().unwrap(),
                        root.start,
                        root.end,
                        root.filesystem.as_ref().unwrap(),
                        root.label.clone(),
                    )?;
                } else if root.format && root.path.is_some() && root.filesystem.is_some() {
                    println!("Formatting the already allocated root");
                    format(
                        root.filesystem.as_ref().unwrap(),
                        root.path.as_ref().unwrap(),
                        root.label.as_deref()
                    )?;
                }

                if let Some(filesystem) = root.to_owned().filesystem {
                    mount(path.as_ref().unwrap(), "/tealinux-mount", None)?;

                    if home.is_none() && filesystem.eq("btrfs")
                    {
                        create_subvolume("/tealinux-mount/@")?;
                        create_subvolume("/tealinux-mount/@home")?;

                        umount("/tealinux-mount")?;

                        mount_subvolume("@", path.as_ref().unwrap(), "/tealinux-mount")?;

                        create_dir("/tealinux-mount/home")?;

                        mount_subvolume("@home", path.as_ref().unwrap(), "/tealinux-mount/home")?;
                    }
                }

                println!("Done dealing with root");
            }

            // Deal with rest of the partition

            println!("Dealing with the rest of the partition");
            for i in partitions {
                if let Some(mountpoint) = i.to_owned().mountpoint {
                    // Ignore root

                    if !mountpoint.eq("/") {
                        if mountpoint.contains("swap") {
                            cmd!("swapon", i.path.as_ref().unwrap()).run()?;
                        }

                        if mountpoint.contains("boot") {
                            cmd!(
                                "mkdir",
                                "--parents",
                                format!("/tealinux-mount{}", mountpoint)
                            )
                            .run()?;
                            mount(
                                i.path.as_ref().unwrap(),
                                &format!("/tealinux-mount{}", mountpoint),
                                None,
                            )?;
                        }
                    }
                }
            }

            Ok(())
        }
        None => Err(Error::from(ErrorKind::NotFound)),
    }
}
